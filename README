luafcgid - a statefull FastCGI daemon for Lua

---
SUMMARY
---

luafcgid is a multithreaded FastCGI server that runs under BSD/Linux/MacOSX and
Windows (using MinGW and pthreads32). It manages a number of independent, 
persistent Lua states, that are then loaded with Lua scripts from the file 
system. These scripts are loaded/initialized on demand, and held in memory for 
as long as possible. The Lua scripts are also allowed to interface with the 
FastCGI libraries: thus providing an extremely fast, streamlined and 
lightweight platform from which to develop web-centric apps in Lua.


All development testing is done with the following server platform:

-= luafcgid reference platform =-

Hardware:

Pentium 4 3+ Ghz
Intel MB chipset
Intel Pro+ 1GB Ethernet
2GB RAM

Software:

FreeBSD - last stable release
nginx web server - last stable release
Lua - last stable release
libthr - drop-in replacement for libpthread


** NOTE: Further testing may be done on other platforms when available. 
** Volunteers welcome. 

---
DESIGN
---

The basic design of luafcgid is currently based off of the "threaded.c" example 
provided in the official FactCGI devkit. This is where each worker thread 
contains an isolated blocking accept loop. The FastCGI libraries provide a 
connect queue for each worker thread so that transient load spikes can be 
handled with a minimum of fuss.

                           +---------------+                                
                       +-->| worker thread |--+            +-------------+
 +------------------+  |   +---------------+  |            |   script    |
 | luafcgid process |--+                      +-- mutex -->| loaded into |
 +------------------+  |   +---------------+  |            |  Lua state  |
                       +-->| worker thread |--+            +-------------+
                           +---------------+
		
Lua is then introduced into the picture by created a shared Lua state for each 
Lua script that is requested. This setup is inspired by the 'mod_wombat' 
project. A state is initialized and loaded with the script, and is kept 
in memory for as long as possible. This allows for persistence across HTTP 
requests. Each Lua VM is run WITHIN THE WORKER THREAD that needs it. There is
a configurable limit to the total number of Lua states that luafcgid will 
maintain. When this limit is reached, popularity and aging are used to decide
which states to flush and reload with a new script.

---
PREREQUISITES
---

Lua 5.1
libfcgi 2.4
libpthread/libthr/pthreadw32

---
PERFORMANCE
---

Preliminary testing (with 10 worker threads) indicates that this may be a
workable design...

test script:

s = "Hello Word"
function handler()
	return s
end


httperf results:

httperf --timeout=5 --client=0/1 --server=10.0.0.18 --port=80 --uri=/test.lua 
--send-buffer=4096 --recv-buffer=16384 --num-conns=1000 --num-calls=100

Total: connections 1000 requests 100000 replies 100000 test-duration 42.790 s

Connection rate: 23.4 conn/s (42.8 ms/conn, <=1 concurrent connections)
Connection time [ms]: min 35.4 avg 42.8 max 200.4 median 38.5 stddev 18.8
Connection time [ms]: connect 0.1
Connection length [replies/conn]: 100.000

Request rate: 2337.0 req/s (0.4 ms/req)
Request size [B]: 66.0

Reply rate [replies/s]: min 2229.0 avg 2340.1 max 2685.7 stddev 146.9 (8 samples)
Reply time [ms]: response 0.4 transfer 0.0
Reply size [B]: header 177.0 content 88.0 footer 2.0 (total 267.0)
Reply status: 1xx=0 2xx=100000 3xx=0 4xx=0 5xx=0


server load:

  PID USERNAME  THR PRI NICE   SIZE    RES STATE   C   TIME   WCPU COMMAND
40861 www        10   8    0  5664K  1568K nanslp  1   0:02 18.65% luafcgid
40918 www         1  96    0  5132K  3632K RUN     0   0:35  2.88% nginx


** UPDATE **

When using unix sockets instead of localhost TCP:

Connection rate: 32.8 conn/s (30.5 ms/conn, <=1 concurrent connections)
Connection time [ms]: min 27.1 avg 30.5 max 113.5 median 28.5 stddev 8.8
Connection time [ms]: connect 0.1
Connection length [replies/conn]: 100.000

Request rate: 3283.3 req/s (0.3 ms/req)
Request size [B]: 66.0

Reply rate [replies/s]: min 3161.8 avg 3279.4 max 3407.1 stddev 92.3 (6 samples)
Reply time [ms]: response 0.3 transfer 0.0
Reply size [B]: header 177.0 content 87.0 footer 2.0 (total 266.0)
Reply status: 1xx=0 2xx=100000 3xx=0 4xx=0 5xx=0

server load: 

  PID USERNAME  THR PRI NICE   SIZE    RES STATE   C   TIME   WCPU COMMAND
56713 www        10  45    0  5664K  1484K umtxn   1   0:02 21.39% luafcgid
56597 www         1   4    0  5132K  3604K RUN     0   0:34  1.27% nginx